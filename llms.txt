# Tessera

*Accurate tiling of spatial single-cell data with Tessera*

**Tessera** is an algorithm for segmenting single-cell resolution
spatial omics data into small multicellular tiles whose edges track with
natural tissue boundaries. These tiles can then be used in downstream
analysis to label and define tissue regions across samples.

Check out the manuscript on
[bioRxiv](https://www.biorxiv.org/content/10.1101/2025.01.17.633630v1)
for additional details.

![](reference/figures/cartoon.png)

## Overview

The Tessera algorithm takes as input single cells (or pixels) with
spatial coordinates and cell embeddings (or transcript counts) for each
cell. The output is a segmentation of adjacent cells into tiles with a
user-controlled size parameter. Boundaries between tiles align with
where cell composition and gene expression change the most within the
tissue. Segmentation using the Tessera algorithm has four main steps:

1.  *Constructing inputs:* A triangle mesh is constructed using Delauney
    triangulation and pruned to eliminate long edges. If transcript
    counts are provided for each cell instead of embeddings, then cell
    embeddings are computed using principal component analysis (PCA).
2.  *Gradient estimation:* Gradients are calculated at each vertex by
    considering the difference in cell embeddings between each cell and
    its neighbors in the mesh. These gradients are smoothed using
    anisotropic bilateral filtering, and then gradients are defined for
    edges and triangles in the mesh by averaging the vertices that each
    edge or triangle contains.
3.  *Tissue segmentation using discrete Morse theory (DMT):* A scalar
    field is defined by taking the magnitude of the total gradient at
    each vertex, edge, and triangle. Then DMT-based segmentation is
    performed by constructing a maximum spanning forest on the triangles
    and a minimum spanning forest on the vertices. Separatrices that
    partition cells into tiles of homogeneous composition are defined by
    tracing paths between critical points, specifically between saddle
    edges and maximum triangles.
4.  *Hierarchical agglomeration:* Tiles from DMT-based segmentation are
    merged using single-linkage agglomerative clustering to obtain tiles
    containing a number of cells between a user-provided minimum and
    maximum value. Pairs of adjacent tiles are scored according to their
    transcriptional similarity, compactness of shape after merging, and
    number of cells, in order to prioritize favorable merges in each
    agglomerative clustering step.

## System Requirements

### OS Requirements

`tessera` is supperted for *macOS* and *Linux*. The package has been
tested on the following systems:

- macOS: Sonoma (14.6.1)
- Linux: CentOS 7 (7.9.2009)

### R Dependencies

`tessera` has been tested on R versions \>= 4.3. Please consult the
DESCRIPTION file for more details on required R packages, including Rcpp
for R and C++ integraion.

## Installation

### Install from GitHub

Open R and run:

``` r
devtools::install_github('korsunskylab/tessera')
```

This will install dependencies from CRAN, which can be slow and fails on
some systems. Instead, it is recommended to install the dependencies
manually using conda/mamba (see below).

### Manually install dependencies with conda/mamba (recommended)

In the command line:

``` bash
mamba create -n tessera_env
mamba activate tessera_env

## If using macOS with Apple Silicon:
# conda config --env --set subdir osx-64

# Install required dependencies (~1 min)
mamba install -c conda-forge r-essentials r-rcpp r-rcpparmadillo r-bh r-devtools \
r-tidyverse r-matrix r-rlang r-r.utils r-sf r-igraph r-furrr r-future r-data.table \
r-geometry r-mclust r-rspectra r-magrittr r-harmony

# Optionally install Seurat and additional packages to run vignettes (~15 sec)
mamba install -c conda-forge r-seurat r-ggthemes r-patchwork r-viridis jupyterlab r-irkernel
```

Next, in an R console:

``` r
devtools::install_github('korsunskylab/tessera', dependencies = FALSE)  # ~1 min
```

## Quick Start

### Standalone Mode

Check out
[`vignette("vignette_basic")`](https://korsunskylab.github.io/tessera/articles/vignette_basic.md)
for a quick start tutorial which demonstrates using `tessera` in
standalone mode on a single sample.

The basic usage is as follows:

``` r
res = GetTiles(
    X = meta_data$X,         # Vector of cell spatial coordinates
    Y = meta_data$Y,         # Vector of cell spatial coordinates
    counts = counts,         # Gene-by-cell matrix of transcript counts

    embeddings = embeddings, # (Optional) Cell-by-embedding matrix of pre-computed cell embeddings. If missing, embeddings are calculated using PCA.
    meta_data = meta_data,   # (Optional) Additional cell meta data
    meta_vars_include = meta_vars_include, # (Optional) Cell meta data to include in output

    group.by = 'sample_id',  # (Optional) Name of meta_data column that provides sample IDs. If missing, treated as a single sample.

    # Additional Tessera algorithm parameters
    dims.use = 1:25,                                   # Choose how many embedding dimensions to use
    prune_thresh_quantile = 0.99, prune_min_cells = 1, # Control pruning of long edges and disconnected cells
    max_npts = 50, min_npts = 5,                       # Control size of Tessera tiles
    ...                      
)
dmt = res$dmt                # Mesh data structures with results from segmentation
aggs = res$aggs              # Tiles resulting from DMT-based segmentation and agglomeration
```

### Seurat Objects (Multi-sample)

Tessera can also be applied directly to a Seurat object containing
single cells with spatial coordinates. The `GetTiles` function can use
cell embeddings that have already been pre-computed (and integrated, if
there are multiple samples). By default, the output is a pair of Seurat
objects: 1) a single-cell Seurat object updated with tile assignments
for each cell, and 2) a Seurat object where each entry represents an
individual Tessera tile.

``` r
options(future.globals.maxSize= 4*1024^3)   # For larger datasets, the memory allowance may need to be increased for parallelization
future::plan(future::multicore)             # Parallelize over multiple samples (if doing multi-sample analysis)
res = GetTiles(
    obj,        # Single-cell Seurat object
    'spatial',  # Name of dimesional reduction where x/y coordinates are stored

    embeddings = 'harmony',  # (Optional) Name of dimensional reduction where pre-computed single-cell embeddings are stored
    group.by = 'sample_id',  # (Optional) Name of meta.data column that provides sample IDs. If missing, treated as a single sample.

    # Additional Tessera algorithm parameters
    dims.use = 1:25,                                   # Choose how many embedding dimensions to use
    prune_thresh_quantile = 0.99, prune_min_cells = 1, # Control pruning of long edges and disconnected cells
    max_npts = 50, min_npts = 5,                       # Control size of Tessera tiles
    ...
)
obj = res$obj                # Seurat object of single-cells (with cell-to-tile mapping)
tile_obj = res$tile_obj      # Seurat object of Tessera tiles
```

## Vignettes:

1.  Quickstart (approx. runtime: \<10 sec):
    [`vignette("vignette_basic")`](https://korsunskylab.github.io/tessera/articles/vignette_basic.md)

<https://github.com/korsunskylab/tessera/blob/main/vignettes/vignette_basic.ipynb>

2.  Walkthrough (approx. runtime: \<10 sec):
    [`vignette("vignette_stepthrough")`](https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.md)

<https://github.com/korsunskylab/tessera/blob/main/vignettes/vignette_stepthrough.ipynb>

# Package index

## All functions

- [`AddAggsAdjacencyMatrix()`](https://korsunskylab.github.io/tessera/reference/AddAggsAdjacencyMatrix.md)
  : Construct tile adjacency matrix from consolidated GetTiles output.
- [`ConsolidateResults()`](https://korsunskylab.github.io/tessera/reference/ConsolidateResults.md)
  : Consolidate Tessera results from multiple samples (groups) after
  constructing Tessera tiles separately on cells from each group.
- [`GetTiles()`](https://korsunskylab.github.io/tessera/reference/GetTiles.md)
  : Generic function that runs the Tessera algorithm on single-cell
  spatial data
- [`GetTiles(`*`<Seurat>`*`)`](https://korsunskylab.github.io/tessera/reference/GetTiles.Seurat.md)
  : Applies Tessera on a Seurat object
- [`GetTiles(`*`<default>`*`)`](https://korsunskylab.github.io/tessera/reference/GetTiles.default.md)
  : Run full DMT segmentation pipeline to make aggregated tiles from
  cells
- [`RunUMAPCustom()`](https://korsunskylab.github.io/tessera/reference/RunUMAPCustom.md)
  : Run UMAP and save fgraph and embeddings in Seurat object
- [`add_exterior_triangles()`](https://korsunskylab.github.io/tessera/reference/add_exterior_triangles.md)
  : For every edge on the boundary, adds a second degenerate triangle
- [`assign_unique_rowid_cpp()`](https://korsunskylab.github.io/tessera/reference/assign_unique_rowid_cpp.md)
  : Assigns a unique ID to each point with distinct X,Y coordinates
- [`compress_field_cpp()`](https://korsunskylab.github.io/tessera/reference/compress_field_cpp.md)
  : Compress a gradient field using SVD
- [`compress_gradients_svd()`](https://korsunskylab.github.io/tessera/reference/compress_gradients_svd.md)
  : Compress a gradient field using SVD
- [`compute_gradients()`](https://korsunskylab.github.io/tessera/reference/compute_gradients.md)
  : Compute spatial gradient field for input to DMT
- [`compute_gradients_edges()`](https://korsunskylab.github.io/tessera/reference/compute_gradients_edges.md)
  : Compute spatial gradient field for input to DMT
- [`dmt_assign_tiles()`](https://korsunskylab.github.io/tessera/reference/dmt_assign_tiles.md)
  : Assign points to tiles after DMT
- [`dmt_get_separatrices()`](https://korsunskylab.github.io/tessera/reference/dmt_get_separatrices.md)
  : Get separatrices that separate points into components with strong
  boundaries
- [`dmt_init_tiles()`](https://korsunskylab.github.io/tessera/reference/dmt_init_tiles.md)
  : Initialize tiles with shapes and other properties
- [`dmt_set_f()`](https://korsunskylab.github.io/tessera/reference/dmt_set_f.md)
  : Set DMT scalar field values as the Frobenius norm of the total
  derivative
- [`do_dmt_forest_cpp()`](https://korsunskylab.github.io/tessera/reference/do_dmt_forest_cpp.md)
  : Construct maximum spanning forest
- [`do_dual_forest()`](https://korsunskylab.github.io/tessera/reference/do_dual_forest.md)
  : Construct dual maximum spanning forest on triangles
- [`do_pca()`](https://korsunskylab.github.io/tessera/reference/do_pca.md)
  : Compute PCA embeddings from a raw counts matrix
- [`do_primary_forest()`](https://korsunskylab.github.io/tessera/reference/do_primary_forest.md)
  : Construct primal minimum spanning forest on points
- [`estimate_field()`](https://korsunskylab.github.io/tessera/reference/estimate_field.md)
  : Compute a spatial gradient field at each point (cell)
- [`estimate_field_cpp()`](https://korsunskylab.github.io/tessera/reference/estimate_field_cpp.md)
  : Compute a spatial gradient field at each point (cell)
- [`estimate_field_edges_cpp()`](https://korsunskylab.github.io/tessera/reference/estimate_field_edges_cpp.md)
  : Compute a spatial gradient field along each edge
- [`findDuplicates()`](https://korsunskylab.github.io/tessera/reference/findDuplicates.md)
  : Find duplicates within a vector
- [`get_e_sep()`](https://korsunskylab.github.io/tessera/reference/get_e_sep.md)
  : Get the collection of edges that lie along separatrices
- [`init_data()`](https://korsunskylab.github.io/tessera/reference/init_data.md)
  : Generate mesh data structure from coordinates, for input to DMT
  analysis
- [`init_edges_cpp()`](https://korsunskylab.github.io/tessera/reference/init_edges_cpp.md)
  : Calculates triangles' centroids, areas, and heights from vertices
- [`init_scores()`](https://korsunskylab.github.io/tessera/reference/init_scores.md)
  : Initialize tile scores for aggregation
- [`init_tris_cpp()`](https://korsunskylab.github.io/tessera/reference/init_tris_cpp.md)
  : Calculates triangles' centroids, areas, and heights from vertices
- [`inv_svd_field_cpp()`](https://korsunskylab.github.io/tessera/reference/inv_svd_field_cpp.md)
  : Inverse SVD transform to reconstruct spatial gradient field
- [`mergeListsToArmaUVec()`](https://korsunskylab.github.io/tessera/reference/mergeListsToArmaUVec.md)
  : Copies elements from two lists an Armadillo uvec
- [`merge_aggs()`](https://korsunskylab.github.io/tessera/reference/merge_aggs.md)
  : Merges tiles using single-linkage agglomerative clustering
- [`merge_aggs_cpp()`](https://korsunskylab.github.io/tessera/reference/merge_aggs_cpp.md)
  : Merges tiles using single-linkage agglomerative clustering
- [`normalize_data()`](https://korsunskylab.github.io/tessera/reference/normalize_data.md)
  : Log-normalization for counts data
- [`procrustes_inner()`](https://korsunskylab.github.io/tessera/reference/procrustes_inner.md)
  : Computes the procrustes inner product between two matrices
- [`procrustes_mat()`](https://korsunskylab.github.io/tessera/reference/procrustes_mat.md)
  : Solves the orthogonal procrustes problem
- [`prune_graph()`](https://korsunskylab.github.io/tessera/reference/prune_graph.md)
  : Prunes mesh by eliminating long edges and small connected components
- [`scaleRows_dgc()`](https://korsunskylab.github.io/tessera/reference/scaleRows_dgc.md)
  : Z-score a sparse matrix across each row
- [`scale_data()`](https://korsunskylab.github.io/tessera/reference/scale_data.md)
  : Z-score a sparse matrix across each row or column
- [`smooth_embedding()`](https://korsunskylab.github.io/tessera/reference/smooth_embedding.md)
  : Smooth embeddings along edges
- [`smooth_field()`](https://korsunskylab.github.io/tessera/reference/smooth_field.md)
  : Bilateral / anisotropic filtering of gradient field
- [`smooth_field_cpp()`](https://korsunskylab.github.io/tessera/reference/smooth_field_cpp.md)
  : Bilateral / anisotropic filtering of gradient field
- [`smooth_field_edges()`](https://korsunskylab.github.io/tessera/reference/smooth_field_edges.md)
  : Bilateral / anisotropic filtering of gradient field
- [`smooth_field_edges_cpp()`](https://korsunskylab.github.io/tessera/reference/smooth_field_edges_cpp.md)
  : Bilateral / anisotropic filtering of gradient field
- [`svd_field_cpp()`](https://korsunskylab.github.io/tessera/reference/svd_field_cpp.md)
  : Compute the SVD of a spatial gradient field at each point (or
  edge/triangle)
- [`tessera-package`](https://korsunskylab.github.io/tessera/reference/tessera.md)
  [`tessera`](https://korsunskylab.github.io/tessera/reference/tessera.md)
  : Accurate tiling of spatial single-cell data
- [`tessera_warmup`](https://korsunskylab.github.io/tessera/reference/tessera_warmup.md)
  : Sample data for Tessera vignettes
- [`trace_back_cpp()`](https://korsunskylab.github.io/tessera/reference/trace_back_cpp.md)
  : Trace back from a point to its root in the spanning forest
- [`trace_epaths_cpp()`](https://korsunskylab.github.io/tessera/reference/trace_epaths_cpp.md)
  : Trace all paths from saddles to critical points in the spanning
  forest
- [`trace_paths()`](https://korsunskylab.github.io/tessera/reference/trace_paths.md)
  : Trace all paths from saddles to dual critical points in the spanning
  forest.
- [`trace_polygons()`](https://korsunskylab.github.io/tessera/reference/trace_polygons.md)
  : Contruct shapes that outline each tile
- [`trace_polygons_cpp()`](https://korsunskylab.github.io/tessera/reference/trace_polygons_cpp.md)
  : Contruct shapes that outline each tile
- [`update_E_cpp()`](https://korsunskylab.github.io/tessera/reference/update_E_cpp.md)
  : Updates information for boundaries after merging two tiles
- [`update_V_cpp()`](https://korsunskylab.github.io/tessera/reference/update_V_cpp.md)
  : Updates information for tiles after merging two tiles
- [`update_agg_shapes()`](https://korsunskylab.github.io/tessera/reference/update_agg_shapes.md)
  : Update shapes and counts matrix for tiles after merging
- [`update_dmt_aggid()`](https://korsunskylab.github.io/tessera/reference/update_dmt_aggid.md)
  : Update tile IDs in the DMT data structure after merging

# Articles

### All vignettes

- [Quickstart: Using Tessera on a Single
  Sample](https://korsunskylab.github.io/tessera/articles/vignette_basic.md):
- [Walkthrough: Tessera Algorithm
  Step-by-Step](https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.md):
