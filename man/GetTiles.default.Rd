% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_ui.R
\name{GetTiles.default}
\alias{GetTiles.default}
\title{Run full DMT segmentation pipeline to make aggregated tiles from cells}
\usage{
\method{GetTiles}{default}(
  X,
  Y,
  counts = NULL,
  embeddings = NULL,
  loadings = NULL,
  meta_data = NULL,
  meta_vars_include = NULL,
  group.by = NULL,
  npcs = 10,
  prune_thresh_quantile = 0.95,
  prune_min_cells = 10,
  prune_thresh = NA,
  smooth_distance = c("none", "euclidean", "projected", "constant")[3],
  smooth_similarity = c("none", "euclidean", "projected", "constant")[3],
  smooth_iter = 1,
  max_npts = 50,
  min_npts = 5,
  alpha = 1,
  .progress = TRUE,
  .options = NULL,
  future.globals.maxSize = 8 * 1024^3,
  consolidate = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{X, Y}{A pair of numeric vectors with the coordinates for each of \code{num_cells} points.}

\item{counts}{A \code{num_genes} x \code{num_cells} gene-by-cell matrix of transcript counts.
Optional if \code{embeddings} are provided directly.}

\item{embeddings}{A \code{num_cells} x \code{num_dim} matrix of cell embeddings across all latent dimensions.
If missing, cell embeddings are calculated using PCA. If provided, the \code{npcs} parameter is ignored.}

\item{loadings}{(Optional) A \code{num_genes} x \code{num_dim} matrix of gene loadings.}

\item{meta_data}{A data frame with additional cell metadata to include in \code{dmt$pts}.}

\item{meta_vars_include}{Names of columns in meta_data to include in \code{dmt$pts}.}

\item{group.by}{Name of column in \code{meta_data} that provides the group IDs. Tessera tiles are
constructed separately for each group (which could be separate experimental samples or FOVs).}

\item{npcs}{Number of PCs to compute for input to segmentation.}

\item{prune_thresh_quantile}{Floating point value between 0 and 1, inclusive.
Quantile of edge length above which edges are pruned. Defaults to 0.95.}

\item{prune_min_cells}{Minimum number of cells required for a connected
component of triangles to be kept. Defaults to 10.}

\item{prune_thresh}{Edge length above which edges are pruned. If equal to NA,
then this value is ignored and \code{thresh_quantile} is used to compute
the threshold. Otherwise, if \code{thresh} is set, then \code{thresh_quantile}
is ignored. Defaults to NA.}

\item{smooth_distance}{One of \code{c('none', 'euclidean', 'projected', 'constant')}.
If either \code{smooth_distance} or \code{smooth_similarity} is \code{'none'},
then no smoothing of the gradient field is conducted. Defaults to \code{'projected'}.}

\item{smooth_similarity}{One of \code{c('none', 'euclidean', 'projected', 'constant')}.
If either \code{smooth_distance} or \code{smooth_similarity} is \code{'none'},
then no smoothing of the gradient field is conducted. Defaults to \code{'projected'}.}

\item{smooth_iter}{Number of rounds of gradient smoothing.}

\item{max_npts}{Maximum number of cells allowed in each tile during the
agglomerative clustering phase.}

\item{min_npts}{Minimum number of cells allowed in each tile during the
agglomerative clustering phase.}

\item{alpha}{Parameter for scoring transcriptional similarity between adjacent tiles during
the agglomerative clustering phase. For \code{alpha}, 0.2 = conservative merging, 2 = liberal merging.}

\item{future.globals.maxSize}{Maximum allowed size (in bytes) of global variables that are exported to each parallel worker.
Increase this value if you get an error about global object size. Default is 8*1024^3 (8 GB).}

\item{consolidate}{Whether to consolidate results from multiple groups into a single collection of
points and tiles (TRUE) or to return a list of separate results for each group (FALSE).}

\item{verbose}{Whether to print progress messages for each stage of the segmentation pipeline.}
}
\value{
If \code{consolidate==TRUE}, a List with the results of segmentation, combined across groups
(otherwise, if \code{consolidate==FALSE}, a named List, which contains separate results for each group):
\item{dmt}{Mesh data structures with input points/edges/triangles and the results from segmentation:
\itemize{
\item \code{pts}: A data table with \code{num_cells_pruned} rows containing cells in the mesh that
remain after Delauney triangulation and pruning, with the following columns:
\itemize{
\item \code{X},\code{Y}: Coordinates of each cell.
\item \code{ORIG_ID}: Index of each cell in the original inputs to \code{GetTiles()} (\code{X}, \code{Y}, \code{counts}, \code{meta_data})
\item Columns from \code{meta_vars_include}.
\item \code{f}: Scalar value used for initial DMT-based segmentation, computed from the spatial gradient
in expression at each point.
\item \code{agg_id}: Unique ID for the tile that each point belongs to in the final segmentation.
}
\item \code{tris}: A data table with \code{num_triangles} rows containing triangles in the mesh after
Delauney triangulation and pruning, with the following columns:
\itemize{
\item \code{X},\code{Y}: Coordinates of each triangle's centroid.
\item \code{area}: Area of triangle.
\item \code{height}: Largest height of each triangle.
\item \code{external}: Logical value that is \code{TRUE} if the triangle is a degenerate triangle
that was added along a boundary edge to ensure that every edge is adjacent to two
triangles. Degenerate triangles only have two vertices (the endpoints of the boundary edge).
\item \code{f}: Scalar value used for initial DMT-based segmentation, computed from the spatial gradient
in expression for triangle.
}
\item \code{edges}: A data table with \code{num_edges} rows containing edges between adjacent points and triangles
in the mesh after Delauney triangulation and pruning, with the following columns:
\itemize{
\item \code{from_pt},\code{to_pt}: Indices of the two adjacent cells that are connected by an edge.
\item \code{from_tri},\code{to_tri}: Indices of the two adjacent triangles that are connected by an edge.
\item \code{x0_pt},\code{x1_pt},\code{y0_pt},\code{y1_pt}: Coordinates of the two adjacent cells that are connected by an edge.
\item \code{x0_tri}, \code{x1_tri}, \code{y0_tri}, \code{y1_tri}: Coordinates of the two adjacent triangles (centroids) that are connected by an edge.
\item \code{length_pt}, \code{length_tri}: Distance between adjacent cells or triangle centroids. Used for pruning step.
(Warning - these are computed prior to pruning and are not updated after pruning and adding exterior triangles.)
\item \code{boundary}: Logical value that is \code{TRUE} if the edge is at the boundary and is adjacent to
only a single internal triangle. For boundary edges, a degenerate external triangle is added along
the boundary edge to ensure that every edge is adjacent to two triangles.
\item \code{f_prim},\code{f_dual}: Scalar values used for initial DMT-based segmentation, computed from the spatial gradient
in expression at each edge. Primal edges connect points and average the \code{f} values at the two adjacent points.
Dual edges connect triangles and average the \code{f} values at the two adjacent triangles.
\item \code{agg_from},\code{agg_to}: Unique ID for the tile that each adjacent point belongs to in the final segmentation.
}
\item \code{tri_to_pt}: A \code{num_triangles} x \code{num_cells_pruned} sparse matrix with value 1 at \verb{(i,j)} if
triangle \code{i} has point \code{j} as a vertex. Each internal triangle has 3 vertices, and each degenerate
external triangle has 2 vertices.
\item \code{counts}: A \code{num_genes} x \code{num_cells_pruned} gene-by-cell matrix of transcript counts.
\item \code{udv_cells}: A List with the PC embeddings for each cell, which are used for segmentation.
\itemize{
\item \code{loadings}: If not provided as input, a \code{num_genes} x \code{npcs} matrix of gene loadings
for each PC. Each column is a unit vector.
\item \code{embeddings}: If not provided as input, a \code{num_cells} x \code{npcs} matrix of cell
embeddings across all PCs. Each column \code{j} has magnitude
equal to the \code{j}th singular value. That is, PCs with
larger contribution to the total variance will have
embeddings of proportionally larger magnitude.
}
\item \code{prim}: The primal minimum spanning forest on points. A List with the following attributes:
\itemize{
\item \code{edges}: A data table with \code{forest_size} rows, where each row is a directed edge
in the minimum spanning forest. There are six columns:
\itemize{
\item \verb{from,to}: Index of source and target points for each edge.
\item \verb{x0,y0}: Coordinates of source point for each edge.
\item \verb{x1,y1}: Coordinates of target point for each edge.
}
\item \code{saddles}: A length \code{num_saddles} vector with edge indices for possible saddle edges.
\item \code{labels}: A length \code{num_points} vector of labels for the connected components in the
minimum spanning tree. Each connected component is labeled by the index of its critical point.
\item \code{minima}: A length \code{num_critpts} vector of critical points (minima).
\item \code{parent}: A length \code{num_points} vector containing the parent (source) point for each
point in the directed spanning forest. Critical points have no parent, so the value should be ignored.
\item \code{parent_edge}: A length \code{num_points} vector containing the directed edge that has
each point as a target node. Critical points have no parent edge, so the value should be ignored.
}
\item \code{dual}: The dual maximum spanning forest on triangles. A List with the following attributes:
\itemize{
\item \code{edges}: A data.table with \code{forest_size} rows, where each row is a directed edge
in the maximum spanning forest. There are six columns:
\itemize{
\item \verb{from,to}: Index of source and target triangles for each edge.
\item \verb{x0,y0}: Coordinates of source triangle for each edge.
\item \verb{x1,y1}: Coordinates of target triangle for each edge.
}
\item \code{saddles}: A length \code{num_saddles} vector with edge indices for possible saddle edges.
\item \code{labels}: A length \code{num_triangles} vector of labels for the connected components in the
maximum spanning tree. Each connected component is labeled by the index of its critical triangle.
\item \code{maxima}: A length \code{num_critpts} vector of critical triangles (maxima).
\item \code{parent}: A length \code{num_triangles} vector containing the parent (source) triangle for each
triangle in the directed spanning forest. Critical triangles have no parent, so the value should be ignored.
\item \code{parent_edge}: A length \code{num_triangles} vector containing the directed edge that has
each triangle as a target node. Critical triangles have no parent edge, so the value should be ignored.
}
\item \code{e_sep}: A length \code{num_sep_edges} vector of edge indices that make up the separatrices,
which separate points into different components.}}
\item{aggs}{The tiles that result from DMT-based segmentation and agglomeration.
A List data structure stores the tiles and their adjacencies using the following attributes:
\itemize{
\item \code{meta_data}: A data table with \code{num_tiles} rows with metadata for each tile:
\itemize{
\item \code{ID}: Unique ID for each tile.
\item \code{X},\code{Y}: Centroid of each tile.
\item \code{npts}: Number of points in each tile.
\item \code{shape}: A \code{sfc} list-column with the geometries for each tile.
\item \verb{area,perimeter}: Area and perimeter of each tile.
}
\item \code{edges}: Additional attributes are calculated:
\itemize{
\item \verb{from,to}: Tile IDs for the two tiles bordering this edge.
\item \verb{x0,y0,x1,y1}: Centroid coordinates for the two tiles bordering this edge.
\item \verb{area,npts}: Sum of areas and numbers of points in the two tiles bordering this edge.
\item \code{edge_length}: Total length of the border between the \code{from} and \code{to} tiles.
\item \code{dscore}: Overall score for merging two tiles. Product of \code{w}, \code{score_size}, and \code{dC}.
\item \code{w}: Gene expression similarity score.
\item \code{score_size}: Penalizes tiles with many points.
\item \code{perimeter_merge}: Perimeter of merged tile.
}
\item \code{pcs}: A \code{num_tiles} x \code{npcs} matrix with the average embedding value over all cells
in each tile.
\item \code{pcs_merged}: A \code{num_edges} x \code{npcs} matrix with average PCs for the new tile if
the two adjacent tiles connected by the edge were merged.
\item \code{d_mu},\code{d_sig}: Parameters used to calculate \code{w} in the edge score \code{dscore}.
\item \code{aggmap}: A length \code{orig_num_tiles} vector mapping each original tile ID to the new
tile IDs after merging.
\item \code{adj}: Sparse adjacency matrix between all tiles (if \code{consolidate==TRUE}).
\item \code{counts}: A \code{num_genes} x \code{num_tiles} gene-by-tile matrix of aggregated transcript counts.}
}
}
\description{
Segmentation has four main steps:
\enumerate{
\item \strong{Preparing data structures:} A triangle mesh is constructed using Delauney
triangulation and pruned to eliminate long edges. PC embeddings for each
each are computed.
\item \strong{Computing gradients:} Gradients are calculated at each point by considering
the difference in expression between each cell in its neighbors in the mesh.
These gradients are smoothed using (anisotropic) bilateral filtering, and then
gradients are defined for edges and triangles in the mesh by averaging the
points that each edge or triangle contains.
\item \strong{DMT:} A scalar field is defined by taking the magnitude of the total gradient
at each point/edge/triangle. Then DMT-based segmentation is performed by constructing
a maximum spanning forest on the triangles and a minimum spanning forest on the points.
Separatrices that separate cells into tiles of homogeneous composition are defined
by tracing paths between critical points, particularly between saddle edges and maximum
triangles.
\item \strong{Aggregation:} Tiles from DMT-based segmentation are merged using single-linkage
agglomerative clustering to obtain tiles containing a number of cells between a
user-provided minimum and maximum value. Pairs of adjacent tiles are scored according
to their transcriptional similarity, compactness of shape after merging, and number
of cells in order to prioritize favorable merges in each agglomerative clustering step.
}
}
\details{
\subsection{Computing gradients (smoothing)}{

Gradient fields are smoothed using bilateral filtering,
in which the smoothed gradient of each point is computed as
the weighted average of the neighbors' gradients, considering
both distance in space and also similarity in gradients.
The weight of each neighbor is computed from the product of two scores:
\itemize{
\item \code{distance} score: Generally, closer neighbors have greater weight.
\itemize{
\item if \code{'euclidean'}: Gaussian transformation of the Euclidean distance
of a cell from its neighbor, so that more distant neighbors have less weight.
\item if \code{'projected'}: An anisotropic filter that accounts for expected
change in expression along the direction of the neighbor. The expected
change in expression is calculated from the gradient field as the total
derivative in the direction of the neighbor. This change in expression is
then Gaussian transformed so that neighbors that are more distant along the
direction of greatest change have less weight.
\item if \code{'constant'}: All neighbors have equal \code{distance} weights
}
\item \code{similarity} score: Generally, neighbors with more similar gradients have
greater weight
\itemize{
\item if \code{'euclidean'}: Gaussian transformation of the Euclidean distance
between a cell's gradient field and its neighbor's gradient field.
\item if \code{'projected'}: Gaussian transformation of the cosine distance
between a cell's gradient field and its neighbor's gradient field.
\item if \code{'constant'}: All neighbors have equal \code{similarity} weights
}
}
}

\subsection{Aggregation (scores)}{

Pairs of adjacent tiles are scored according to their transcriptional similarity,
compactness of shape after merging, and number of cells in order to prioritize
favorable merges in each agglomerative clustering step. The \code{dscore} for each edge
is computed as the product of the following three factors, where higher scores
favor merging of adjacent tiles:
\itemize{
\item \code{w}: A 2-cluster GMM is used to determine the mean \code{mu} and standard deviation \code{sig} of the distance
between tiles that have similar gene expression (Euclidean distance \code{d} in PC space).
Then we define \code{d_mu = mu + sig} and \code{d_sig = alpha * sig}, and calculate \code{w} as
\code{w = 0.5 - 1 / (1 + exp(-(d - d_mu) / d_sig))}. Ranges from -0.5 to 0.5. If adjacent tiles
are very dissimilar (\verb{d >> d_mu}), then \code{d} is large, and \code{w} is close to \code{-0.5}. If adjacent
tiles are very similar (\code{d < d_mu}), then \code{d} is small, and \code{w} is positive.
\item \code{score_size}: \code{(1 - npts_from/max_npts) * (1 - npts_to/max_npts)}. Ranges from 0 to 1.
In the first round of aggregation, if merging the two tiles would have a total number
of points ≥\code{max_npts}, then \code{score_size} is set to \code{-Inf}, which prevents merging.
In the second round of aggregation, \code{dscore} is set to \code{-Inf} if both adjacent tiles
have at least \code{min_npts} cells, to prioritize merging of small tiles.
\item \code{dC}: \code{.5 * (C_merge - C_from - C_to + 1)}. Ranges from 0 to 1.
}
}
}
\seealso{
Other GetTiles: 
\code{\link{GetTiles}()},
\code{\link{GetTiles.Seurat}()}
}
\concept{GetTiles}
